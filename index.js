function arrayHasSame(e,r){if(!e.length||!r.length)return!1;const t=new Set(r);return!![...new Set(e)].filter(e=>t.has(e)).length}function arrayUnique(e){return e.length?[...new Set(e)]:[]}function arrayIntersect(e,r){if(!e.length||!r.length)return[];const t=new Set(r);return[...new Set(e)].filter(e=>t.has(e))}function isFunction(e){return"[object Function]"===Object.prototype.toString.call(e)}function isObjectLike(e){return null!=e&&"object"==typeof e}function isString(e){return"string"==typeof e}function toString(e){if(!e)return"";if("string"==typeof e)return e;const r=e.toString();return"0"===r&&1/e===Number.NEGATIVE_INFINITY?"-0":r}const TYPES_ENUM={BOOLEAN:"boolean",NUMERIC:"numeric",INTEGER:"integer",STRING:"string",JSON:"json"},TYPES_LIST=["boolean","numeric","integer","string","json"];class AlterMe{constructor(e,r={}){this.setConfig(r),this.setData(e)}setConfig(e={}){if(!isObjectLike(e))throw new TypeError("'Config' should be an object");return this.config={cast:{},defined:[],omit:[],pick:[],rename:{},replace:{},required:[],transform:{}},this.setConfigOmit(e.omit),this.setConfigCast(e.cast),this.setConfigDefined(e.defined),this.setConfigPick(e.pick),this.setConfigRename(e.rename),this.setConfigReplace(e.replace),this.setConfigRequired(e.required),this.setConfigTransform(e.transform),this.checkConfig(),this}setConfigCast(e={}){if(!isObjectLike(e))throw new TypeError("'cast' should be an object");const r={};return Object.keys(e).forEach(t=>{if(!isString(e[t]))throw new TypeError(`'cast' expect object values to be strings. Not a string at key: <${e[t]}>.`);if(!TYPES_LIST.includes(e[t]))throw new TypeError(`'cast' has unknown type in {${t}: "${e[t]}"}.`);r[t]=e[t]}),this.config.cast=r,this}setConfigDefined(e=[]){if(!Array.isArray(e))throw new TypeError("'defined' should be an array");return this.config.defined=arrayUnique(e).map(e=>{if(!isString(e))throw new TypeError(`'defined' expect array of strings. Value: <${e.toString()}>.`);return e}),this}setConfigOmit(e=[]){if(!Array.isArray(e))throw new TypeError("'omit' should be an array");return this.config.omit=arrayUnique(e).map(e=>{if(!isString(e))throw new TypeError(`'omit' expect array of strings. Value: <${e.toString()}>.`);return e}),this}setConfigPick(e=[]){if(!Array.isArray(e))throw new TypeError("'pick' should be an array");return this.config.pick=arrayUnique(e).map(e=>{if(!isString(e))throw new TypeError(`'pick' expect array of strings. Value: <${e.toString()}>.`);return e}),this}setConfigRename(e={}){if(!isObjectLike(e))throw new TypeError("'rename' should be an object");const r={};Object.keys(e).forEach(t=>{if(!isString(t))throw new TypeError(`'rename' expect object values to be strings. Not a string at key: <${t}>.`);r[t]=e[t]});const t=Object.values(this.config.rename),i=arrayIntersect(t,arrayUnique(t));if(t.length!==i.length)throw new Error(`'rename' has similar values: ${i.join(",")}.`);return this.config.rename=r,this}setConfigReplace(e={}){if(!isObjectLike(e))throw new TypeError("'replace' should be an object");return this.config.replace={...e},this}setConfigRequired(e=[]){if(!Array.isArray(e))throw new TypeError("'required' should be an array");return this.config.required=arrayUnique(e).map(e=>{if(!isString(e))throw new TypeError(`'required' expect array of strings. Value: <${e.toString()}>.`);return e}),this}setConfigTransform(e={}){if(!isObjectLike(e))throw new TypeError("'transform' should be an object");const r={};return Object.keys(e).forEach(t=>{if(!isFunction(e[t]))throw new TypeError(`'transform' expect object values to be functions. Not a function at key: <${t}>.`);r[t]=e[t]}),this.config.transform=r,this}checkConfig(){if(arrayHasSame(this.config.omit,this.config.cast))throw new Error(`'omit' has same keys as 'cast': ${arrayIntersect(this.config.omit,this.config.cast)}.`);if(arrayHasSame(this.config.omit,this.config.defined))throw new Error(`'omit' has same keys as 'defined': ${arrayIntersect(this.config.omit,this.config.defined)}.`);if(arrayHasSame(this.config.omit,this.config.pick))throw new Error(`'omit' has same keys as 'pick': ${arrayIntersect(this.config.omit,this.config.pick)}.`);if(arrayHasSame(this.config.omit,this.config.rename))throw new Error(`'omit' has same keys as 'rename': ${arrayIntersect(this.config.omit,this.config.rename)}.`);if(arrayHasSame(this.config.omit,this.config.replace))throw new Error(`'omit' has same keys as 'replace': ${arrayIntersect(this.config.omit,this.config.replace)}.`);if(arrayHasSame(this.config.omit,this.config.required))throw new Error(`'omit' has same keys as 'required': ${arrayIntersect(this.config.omit,this.config.required)}.`);if(arrayHasSame(this.config.omit,this.config.transform))throw new Error(`'omit' has same keys as 'transform': ${arrayIntersect(this.config.omit,this.config.transform)}.`);if(arrayHasSame(this.config.cast,this.config.replace))throw new Error(`'cast' has same keys as 'replace': ${arrayIntersect(this.config.cast,this.config.replace)}.`);if(arrayHasSame(this.config.cast,this.config.transform))throw new Error(`'cast' has same keys as 'transform': ${arrayIntersect(this.config.cast,this.config.transform)}.`);if(arrayHasSame(this.config.replace,this.config.transform))throw new Error(`'replace' has same keys as 'transform': ${arrayIntersect(this.config.replace,this.config.transform)}.`);return this}setData(e){if(!isObjectLike(e))throw new TypeError("'data' should be an object");return this.original=e,this.validateData(),this}validateData(){this.cache={},Object.keys(this.original).forEach(e=>{this.config.omit.includes(e)||(this.cache[e]=this.original[e])}),this.config.required.forEach(e=>{if(!(e in this.cache))throw new Error(`Field <${e}> is required.`)}),this.config.defined.forEach(e=>{if(!(e in this.cache))throw new Error(`Field <${e}> is required.`);if(void 0===this.cache[e])throw new Error(`Field <${e}> should have value.`)}),Object.keys(this.config.cast).forEach(e=>{const r=this.config.cast[e];if(!(e in this.cache))throw new Error(`Field <${e}> suppose to be converted to ${r}.`);switch(r){case TYPES_ENUM.BOOLEAN:this.cache[e]=Boolean(this.cache[e]);break;case TYPES_ENUM.NUMERIC:{const r=Number(this.cache[e]);if(Number.isFinite(r))this.cache[e]=r;else{const r=Number.parseFloat(this.cache[e]);Number.isFinite(r)?this.cache[e]=r:this.cache[e]=0}break}case TYPES_ENUM.INTEGER:{const r=Number(this.cache[e]);if(Number.isFinite(r))this.cache[e]=Math.trunc(r);else{const t=Number.parseFloat(this.cache[e]);Number.isFinite(t)?this.cache[e]=Math.trunc(r):this.cache[e]=0}break}case TYPES_ENUM.STRING:this.cache[e]=toString(this.cache[e]);break;case TYPES_ENUM.JSON:this.cache[e]=JSON.parse(JSON.stringify(this.cache[e]));break;default:throw new Error("Unknown value convert error")}}),Object.keys(this.config.transform).forEach(e=>{if(!(e in this.cache))throw new Error(`Field <${e}> suppose to be transformed.`);this.cache[e]=this.config.transform[e](this.cache[e],e)}),Object.keys(this.config.replace).forEach(e=>{this.cache[e]=this.config.replace[e]});const e=Object.keys(this.config.rename).sort((e,r)=>e.localeCompare(r)),r={};if(e.forEach(e=>{if(!(e in this.cache))throw new Error(`Field <${e}> suppose to be renamed.`);r[this.config.rename[e]]=this.cache[e]}),e.forEach(e=>{delete this.cache[e]}),Object.assign(this.cache,r),Object.keys(this.config.pick).length>0){let e={};Object.keys(this.cache).forEach(r=>{this.config.pick.includes(r)&&(e[r]=this.cache[r])}),this.cache=e}return this}getConfig(){return{...this.config}}valueOf(){return{...this.cache}}toJSON(){return{...this.cache}}toString(){return JSON.stringify(this.cache)}}module.exports.TYPES_ENUM=TYPES_ENUM,module.exports.TYPES_LIST=TYPES_LIST,module.exports.AlterMe=AlterMe;